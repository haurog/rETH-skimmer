{"mappings":"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","sources":["node_modules/viem/src/utils/ccip.ts","node_modules/viem/src/errors/ccip.ts","node_modules/viem/src/utils/address/isAddressEqual.ts"],"sourcesContent":["import type { Abi, Address } from 'abitype'\n\nimport { type CallParameters, call } from '../actions/public/call.js'\nimport type { Transport } from '../clients/transports/createTransport.js'\nimport { type BaseError } from '../errors/base.js'\nimport {\n  OffchainLookupError,\n  OffchainLookupResponseMalformedError,\n  OffchainLookupSenderMismatchError,\n} from '../errors/ccip.js'\nimport { HttpRequestError } from '../errors/request.js'\nimport type { Chain } from '../types/chain.js'\nimport type { GetErrorArgs } from '../types/contract.js'\nimport type { Hex } from '../types/misc.js'\n\nimport type { Client } from '../clients/createClient.js'\nimport { decodeErrorResult } from './abi/decodeErrorResult.js'\nimport { encodeAbiParameters } from './abi/encodeAbiParameters.js'\nimport { isAddressEqual } from './address/isAddressEqual.js'\nimport { concat } from './data/concat.js'\nimport { isHex } from './data/isHex.js'\nimport { stringify } from './stringify.js'\n\nexport const offchainLookupSignature = '0x556f1830'\nexport const offchainLookupAbiItem = {\n  name: 'OffchainLookup',\n  type: 'error',\n  inputs: [\n    {\n      name: 'sender',\n      type: 'address',\n    },\n    {\n      name: 'urls',\n      type: 'string[]',\n    },\n    {\n      name: 'callData',\n      type: 'bytes',\n    },\n    {\n      name: 'callbackFunction',\n      type: 'bytes4',\n    },\n    {\n      name: 'extraData',\n      type: 'bytes',\n    },\n  ],\n} as const satisfies Abi[number]\n\nexport async function offchainLookup<TChain extends Chain | undefined,>(\n  client: Client<Transport, TChain>,\n  {\n    blockNumber,\n    blockTag,\n    data,\n    to,\n  }: Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n    data: Hex\n    to: Address\n  },\n): Promise<Hex> {\n  const { args } = decodeErrorResult({\n    data,\n    abi: [offchainLookupAbiItem],\n  }) as unknown as GetErrorArgs<\n    [typeof offchainLookupAbiItem],\n    'OffchainLookup'\n  >\n  const [sender, urls, callData, callbackSelector, extraData] = args\n\n  try {\n    if (!isAddressEqual(to, sender))\n      throw new OffchainLookupSenderMismatchError({ sender, to })\n\n    const result = await ccipFetch({ data: callData, sender, urls })\n\n    const { data: data_ } = await call(client, {\n      blockNumber,\n      blockTag,\n      data: concat([\n        callbackSelector,\n        encodeAbiParameters(\n          [{ type: 'bytes' }, { type: 'bytes' }],\n          [result, extraData],\n        ),\n      ]),\n      to,\n    } as CallParameters)\n\n    return data_!\n  } catch (err) {\n    throw new OffchainLookupError({\n      callbackSelector,\n      cause: err as BaseError,\n      data,\n      extraData,\n      sender,\n      urls,\n    })\n  }\n}\n\nexport async function ccipFetch({\n  data,\n  sender,\n  urls,\n}: { data: Hex; sender: Address; urls: readonly string[] }) {\n  let error = new Error('An unknown error occurred.')\n\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i]\n    const method =\n      url.includes('{sender}') || url.includes('{data}') ? 'GET' : 'POST'\n    const body = method === 'POST' ? { data, sender } : undefined\n\n    try {\n      const response = await fetch(\n        url.replace('{sender}', sender).replace('{data}', data),\n        {\n          body: JSON.stringify(body),\n          method,\n        },\n      )\n\n      let result\n      if (\n        response.headers.get('Content-Type')?.startsWith('application/json')\n      ) {\n        result = (await response.json()).data\n      } else {\n        result = (await response.text()) as any\n      }\n\n      if (!response.ok) {\n        error = new HttpRequestError({\n          body,\n          details: stringify(result.error) || response.statusText,\n          headers: response.headers,\n          status: response.status,\n          url,\n        })\n        continue\n      }\n\n      if (!isHex(result)) {\n        error = new OffchainLookupResponseMalformedError({\n          result,\n          url,\n        })\n        continue\n      }\n\n      return result\n    } catch (err) {\n      error = new HttpRequestError({\n        body,\n        details: (err as Error).message,\n        url,\n      })\n    }\n  }\n\n  throw error\n}\n","import type { Address } from 'abitype'\n\nimport type { Hex } from '../types/misc.js'\nimport { stringify } from '../utils/stringify.js'\n\nimport { BaseError } from './base.js'\nimport { getUrl } from './utils.js'\n\nexport class OffchainLookupError extends BaseError {\n  override name = 'OffchainLookupError'\n  constructor({\n    callbackSelector,\n    cause,\n    data,\n    extraData,\n    sender,\n    urls,\n  }: {\n    callbackSelector: Hex\n    cause: BaseError\n    data: Hex\n    extraData: Hex\n    sender: Address\n    urls: readonly string[]\n  }) {\n    super(\n      cause.shortMessage ||\n        'An error occurred while fetching for an offchain result.',\n      {\n        cause,\n        metaMessages: [\n          ...(cause.metaMessages || []),\n          cause.metaMessages?.length ? '' : [],\n          'Offchain Gateway Call:',\n          urls && [\n            '  Gateway URL(s):',\n            ...urls.map((url) => `    ${getUrl(url)}`),\n          ],\n          `  Sender: ${sender}`,\n          `  Data: ${data}`,\n          `  Callback selector: ${callbackSelector}`,\n          `  Extra data: ${extraData}`,\n        ].flat(),\n      },\n    )\n  }\n}\n\nexport class OffchainLookupResponseMalformedError extends BaseError {\n  override name = 'OffchainLookupResponseMalformedError'\n  constructor({ result, url }: { result: any; url: string }) {\n    super(\n      'Offchain gateway response is malformed. Response data must be a hex value.',\n      {\n        metaMessages: [\n          `Gateway URL: ${getUrl(url)}`,\n          `Response: ${stringify(result)}`,\n        ],\n      },\n    )\n  }\n}\n\nexport class OffchainLookupSenderMismatchError extends BaseError {\n  override name = 'OffchainLookupSenderMismatchError'\n  constructor({ sender, to }: { sender: Address; to: Address }) {\n    super(\n      'Reverted sender address does not match target contract address (`to`).',\n      {\n        metaMessages: [\n          `Contract address: ${to}`,\n          `OffchainLookup sender address: ${sender}`,\n        ],\n      },\n    )\n  }\n}\n","import type { Address } from 'abitype'\n\nimport { InvalidAddressError } from '../../errors/address.js'\n\nimport { isAddress } from './isAddress.js'\n\nexport function isAddressEqual(a: Address, b: Address) {\n  if (!isAddress(a)) throw new InvalidAddressError({ address: a })\n  if (!isAddress(b)) throw new InvalidAddressError({ address: b })\n  return a.toLowerCase() === b.toLowerCase()\n}\n"],"names":["$enWAP","parcelRequire","$60ab7a0f7b94ef87$export$630379c2aa400f99","$60ab7a0f7b94ef87$export$eec6ee9dde8e502e","name","type","inputs","async","$60ab7a0f7b94ef87$export$d6522c9964119b53","client","blockNumber","blockTag","data","to","args","$2G5Zu","decodeErrorResult","abi","sender","urls","callData","callbackSelector","extraData","$49ypl","isAddressEqual","$7I1TK","OffchainLookupSenderMismatchError","result","error","Error","i","length","url","method","includes","body","undefined","response","fetch","replace","JSON","stringify","headers","get","startsWith","json","text","ok","$2ptTg","HttpRequestError","details","$fz8dz","statusText","status","$fGxw3","isHex","OffchainLookupResponseMalformedError","err","message","$60ab7a0f7b94ef87$export$aa421b8052670ca4","data_","call","$h4ww9","concat","$gIoH8","encodeAbiParameters","OffchainLookupError","cause","$59ce1d69480a46fa$export$e655df38b41a5462","$2juPe","BaseError","constructor","super","shortMessage","metaMessages","map","$58eft","getUrl","flat","Object","defineProperty","this","value","$59ce1d69480a46fa$export$a202e6f25b41683e","$59ce1d69480a46fa$export$f4e6b144b80c03db","$3vxBz","$3062b156d346cc8b$export$34ca016df7f376b8","a","b","$2U8Nn","isAddress","InvalidAddressError","address","toLowerCase"],"version":3,"file":"ccip.360df405.js.map"}